(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{411:function(n,a,t){"use strict";t.r(a);var e=t(0),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"_1-1-1-三大内容"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-三大内容"}},[n._v("#")]),n._v(" 1.1.1 三大内容")]),n._v(" "),t("p",[n._v("高阶函数 & 函数抽象：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("重点\n\n   1.重点关注javasctipt的原始类型和引用类型，思考此设计影响的浅拷贝/深拷贝，可变性/不可变性概念。\n\n   2.理解纯函数、高阶函数、函数复用的相关知识、DRY、提升代码复用率。\n\n应用\n\n   1.Shallow Copy => React 性能优化\n\n  2.Compose => Redux Middleware\n")])])]),t("p",[n._v("异步编程模式：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("重点\n\n  1.思考和理解EventLoop中个操作的执行顺序，特别是宏队列和微任务队列的执行顺序。\n\n  2.理解处理异步操作的演变历史，以及Promise、Async/Await 的原理。\n\n应用\n\n  1.MircoTasks => Vue.$nextTick()\n\n  2.单线程 => Vue 依赖跟踪\n")])])]),t("p",[n._v("javascript 设计模式：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("重点\n\n  1.理解各个设计模式的使用场景。\n\n  2.对相似的设计模式（如观察者模式、订阅发布模式、中介者模式）能理解其异同点，打好基础，使后面学习框架的时候更加轻松自然。\n\n应用\n\n  1.订阅发布模式 => Vuex\n\n  2.中间件模式 => Koa\n")])])]),t("h2",{attrs:{id:"_1-1-2-学习技巧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2-学习技巧"}},[n._v("#")]),n._v(" 1.1.2 学习技巧")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("把握本质")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("javascript 中引用类型的值是按引用访问的。")])]),n._v(" "),t("li",[t("p",[n._v("javascript 在运行的时候始终是单线程的，不同的语句块是以队列的形式排列在 EventLoop 中按顺序执行的。")])])])]),n._v(" "),t("li",[t("p",[n._v("思考差异（比较思考它们的区别和用途，加以深刻理解：）")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("Debounce VS Throttle。")])]),n._v(" "),t("li",[t("p",[n._v("宏任务 VS 微任务")])]),n._v(" "),t("li",[t("p",[n._v("代理模式 VS 装饰者模式")])])])]),n._v(" "),t("li",[t("p",[n._v("在思考比较各种各种概念后，动手实现以便，加深理解")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);